importScripts('workbox-sw.prod.v2.1.3.js');
importScripts('/src/js/idb.js');
importScripts('/src/js/db-setup.js');

const workboxSW = new self.WorkboxSW();

// Cache fonts and icons
workboxSW.router.registerRoute(
  /.*(?:googleapis|gstatic)\.com.*$/,
  // `staleWhileRevalidate` is cache first with network fallback
  workboxSW.strategies.staleWhileRevalidate({
    cacheName: 'google-fonts',
    cacheExpiration: {
      maxEntries: 100,
      maxAgeSeconds: 60 * 60 * 24 * 30
    }
  })
);

// Cache CSS library
workboxSW.router.registerRoute(
  'https://cdnjs.cloudflare.com/ajax/libs/material-design-lite/1.3.0/material.indigo-pink.min.css',
  workboxSW.strategies.staleWhileRevalidate({
    cacheName: 'material-css'
  })
);

// Cache all posts
workboxSW.router.registerRoute(
  'https://pwagram-ec297.firebaseio.com/posts.json',
  args => {
    return fetch(args.event.request).then(response => {
      const clonedResponse = response.clone();

      // Clear db table of all past data
      deleteAllData('posts').then(() => {
        // Write new data to table
        clonedResponse.json().then(data => {
          for (let key in data) {
            writeData('posts', data[key]);
          }
        });
      });

      return response;
    });
  }
);

// Make "Sorry this page hasn't been cached" page work, show that page if page hasn't been cached otherwise show cached page
// The first argument of the `registerRoute` method is usually a string or regex pattern to match a route but it can also be a function that returns a boolean
workboxSW.router.registerRoute(
  routeData =>
    routeData.event.request.headers.get('accept').includes('text/html'),
  args => {
    return caches.match(args.event.request).then(response => {
      // If resource exists in cache return cached version
      if (response) {
        return response;
      }
      // Otherwise fetch it from the network as usual
      else {
        return (
          fetch(args.event.request)
            .then(response => {
              return caches.open('dynamic').then(cache => {
                // After fetching, store in cache
                // .put() unlike .add() doesn't make a new request, it simply adds what you already fetched to the cache
                // Must use .clone() here because response is empty since it can only be used once, so you must return a cloned copy
                cache.put(args.event.request.url, response.clone());
                return response;
              });
            })
            // Show offline message for assets which hasn't been dynamically cached yet but which the user has tried to visit while offline
            .catch(err =>
              caches.match('/offline.html').then(response => response)
            )
        );
      }
    });
  }
);

// The `service-worker.js` file generated by the `workbox inject:manifest` command, uses this file as a base and just replaces the contents of the empty array below
workboxSW.precache([]);

//* BACKGROUND SYNC ------------------------------------------------------------------------------------------------------------------

// This event is fired right away if there is an internet connection and also whenever a connection is regained after being lost
self.addEventListener('sync', event => {
  console.log('[SW] Background Syncing...', event);

  if (event.tag === 'sync-new-posts') {
    console.log('[SW] Doing the `sync-new-posts` Task...');

    event.waitUntil(
      readData('sync-posts').then(posts => {
        // For each temp item in the `sync-posts` table send AJAX request to save data, then delete entry from table
        for (let key in posts) {
          const postData = new FormData();
          postData.append('id', posts[key].id);
          postData.append('title', posts[key].title);
          postData.append('location', posts[key].location);
          postData.append('rawLocationLat', posts[key].lat);
          postData.append('rawLocationLng', posts[key].lng);
          postData.append('file', posts[key].picture, `${posts[key].id}.png`); // 3rd param allows you to override the name of the image

          fetch(
            'https://us-central1-pwagram-ec297.cloudfunctions.net/storePostData',
            {
              method: 'POST',
              body: postData
            }
          )
            .then(response => response.json())
            .then(response => {
              console.log('[SW] Sent Data From Background Task:', response);

              // If successful then delete the temp entry from the `sync-posts` table
              deleteSingleItemData('sync-posts', response.id);

              console.log(`[SW] Entry ID: ${response.id} Deleted From Queue!`);
            })
            .catch(err => console.log(err));
        }
      })
    );
  }
});

//* PUSH NOTIFICATIONS ------------------------------------------------------------------------------------------------------------------

self.addEventListener('notificationclick', event => {
  const notification = event.notification;
  const action = event.action;

  // `confirm` here isn't a keyword, it's just the ID we gave to one of the notification buttons inside the `displayConfirmNotification()` function
  if (action === 'confirm') {
    console.log('confirm was chosen');
    notification.close(); // Some devices do this automatically but others like android doesn't so calling it explicitly here
  } else {
    console.log(action);
    // If user clicks on the notification and user had a tab open to the site open the link there, otherwise open it in a new tab
    event.waitUntil(
      clients.matchAll().then(clients => {
        const client = clients.find(c => c.visibilityState === 'visible');

        if (client !== undefined) {
          client.navigate(notification.data.openUrl);
          client.focus();
        } else {
          clients.openWindow(notification.data.openUrl);
        }

        notification.close();
      })
    );
  }
});

self.addEventListener('notificationclose', event => {
  // Can send analytics data here since user didn't interact with notification
  console.log('Notification was closed', event);
});

// Will fire whenever a new push message is sent
self.addEventListener('push', event => {
  console.log('[SW] Push Notification Recieved!');
  alert('[SW] Push Notification Recieved!');

  let data = {};
  if (event.data) {
    data = JSON.parse(event.data.text()); // The notification is sent from the server, see "./functions/index.js"
  }

  const options = {
    body: 'You successfully subscribed to our notification service!',
    icon: '/src/images/icons/app-icon-96x96.png',
    badge: '/src/images/icons/app-icon-96x96.png',
    data: {
      openUrl: data.openUrl
    }
  };

  event.waitUntil(self.registration.showNotification(data.title, options));
});

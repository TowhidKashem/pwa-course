importScripts('workbox-sw.prod.v2.1.3.js');
importScripts('/src/js/idb.js');
importScripts('/src/js/db-setup.js');

const workboxSW = new self.WorkboxSW();

// Cache fonts and icons
workboxSW.router.registerRoute(
  /.*(?:googleapis|gstatic)\.com.*$/,
  // `staleWhileRevalidate` is cache first with network fallback
  workboxSW.strategies.staleWhileRevalidate({
    cacheName: 'google-fonts',
    cacheExpiration: {
      maxEntries: 100,
      maxAgeSeconds: 60 * 60 * 24 * 30
    }
  })
);

// Cache CSS library
workboxSW.router.registerRoute(
  'https://cdnjs.cloudflare.com/ajax/libs/material-design-lite/1.3.0/material.indigo-pink.min.css',
  workboxSW.strategies.staleWhileRevalidate({
    cacheName: 'material-css'
  })
);

// Cache all posts
workboxSW.router.registerRoute(
  'https://pwagram-ec297.firebaseio.com/posts.json',
  args => {
    return fetch(args.event.request).then(response => {
      const clonedResponse = response.clone();

      // Clear db table of all past data
      deleteAllData('posts').then(() => {
        // Write new data to table
        clonedResponse.json().then(data => {
          for (let key in data) {
            writeData('posts', data[key]);
          }
        });
      });

      return response;
    });
  }
);

// Make "Sorry this page hasn't been cached" page work, show that page if page hasn't been cached otherwise show cached page
// The first argument of the `registerRoute` method is usually a string or regex pattern to match a route but it can also be a function that returns a boolean
workboxSW.router.registerRoute(
  routeData =>
    routeData.event.request.headers.get('accept').includes('text/html'),
  args => {
    return caches.match(args.event.request).then(response => {
      // If resource exists in cache return cached version
      if (response) {
        return response;
      }
      // Otherwise fetch it from the network as usual
      else {
        return (
          fetch(args.event.request)
            .then(response => {
              return caches.open('dynamic').then(cache => {
                // After fetching, store in cache
                // .put() unlike .add() doesn't make a new request, it simply adds what you already fetched to the cache
                // Must use .clone() here because response is empty since it can only be used once, so you must return a cloned copy
                cache.put(args.event.request.url, response.clone());
                return response;
              });
            })
            // Show offline message for assets which hasn't been dynamically cached yet but which the user has tried to visit while offline
            .catch(err =>
              caches.match('/offline.html').then(response => response)
            )
        );
      }
    });
  }
);

// The `service-worker.js` file generated by the `workbox inject:manifest` command, uses this file as a base and just replaces the contents of the empty array below
workboxSW.precache([
  {
    "url": "404.html",
    "revision": "0a27a4163254fc8fce870c8cc3a3f94f"
  },
  {
    "url": "favicon.ico",
    "revision": "2cab47d9e04d664d93c8d91aec59e812"
  },
  {
    "url": "index.html",
    "revision": "43460ca99cec3d904f274b528ac8c646"
  },
  {
    "url": "manifest.json",
    "revision": "495ded4de080f7ded2bdf905f3246814"
  },
  {
    "url": "offline.html",
    "revision": "baeb3f30420255242d4f6b634dd6dd2d"
  },
  {
    "url": "service-worker.js",
    "revision": "411115b7c96c562b15de9eec94f0e3f0"
  },
  {
    "url": "src/css/app.css",
    "revision": "b4b57fe18cd5c2ff8ed34b60ca8ef064"
  },
  {
    "url": "src/css/feed.css",
    "revision": "9eb7d2ee0afec10a4688ba5e78c9184d"
  },
  {
    "url": "src/css/help.css",
    "revision": "81922f16d60bd845fd801a889e6acbd7"
  },
  {
    "url": "src/js/app.js",
    "revision": "69a10f13aa72aee625caf623440d1085"
  },
  {
    "url": "src/js/db-setup.js",
    "revision": "3b2b93f13a40fa0f0f3fb9d55d014c30"
  },
  {
    "url": "src/js/feed.js",
    "revision": "118324a0de10486341f7fcb3e2585690"
  },
  {
    "url": "src/js/idb.js",
    "revision": "4cf99bdf27ca95d01f29964b67d784e5"
  },
  {
    "url": "src/js/material.min.js",
    "revision": "e68511951f1285c5cbf4aa510e8a2faf"
  },
  {
    "url": "src/js/utility-functions.js",
    "revision": "b1af7b81de21ffa5dc3a85f66bc62a1d"
  },
  {
    "url": "sw-base.js",
    "revision": "cedd66578cd9e7906efc076bedf47e3e"
  },
  {
    "url": "sw.advance.js",
    "revision": "e1ca229dab80ab89c91c45fadbe5882f"
  },
  {
    "url": "workbox-sw.prod.v2.1.3.js",
    "revision": "a9890beda9e5f17e4c68f42324217941"
  },
  {
    "url": "src/images/main-image-lg.jpg",
    "revision": "31b19bffae4ea13ca0f2178ddb639403"
  },
  {
    "url": "src/images/main-image-sm.jpg",
    "revision": "c6bb733c2f39c60e3c139f814d2d14bb"
  },
  {
    "url": "src/images/main-image.jpg",
    "revision": "5c66d091b0dc200e8e89e56c589821fb"
  },
  {
    "url": "src/images/sf-boat.jpg",
    "revision": "0f282d64b0fb306daf12050e812d6a19"
  }
]);

//* BACKGROUND SYNC ------------------------------------------------------------------------------------------------------------------

// This event is fired right away if there is an internet connection and also whenever a connection is regained after being lost
self.addEventListener('sync', event => {
  console.log('[SW] Background Syncing...', event);

  if (event.tag === 'sync-new-posts') {
    console.log('[SW] Doing the `sync-new-posts` Task...');

    event.waitUntil(
      readData('sync-posts').then(posts => {
        // For each temp item in the `sync-posts` table send AJAX request to save data, then delete entry from table
        for (let key in posts) {
          const postData = new FormData();
          postData.append('id', posts[key].id);
          postData.append('title', posts[key].title);
          postData.append('location', posts[key].location);
          postData.append('rawLocationLat', posts[key].lat);
          postData.append('rawLocationLng', posts[key].lng);
          postData.append('file', posts[key].picture, `${posts[key].id}.png`); // 3rd param allows you to override the name of the image

          fetch(
            'https://us-central1-pwagram-ec297.cloudfunctions.net/storePostData',
            {
              method: 'POST',
              body: postData
            }
          )
            .then(response => response.json())
            .then(response => {
              console.log('[SW] Sent Data From Background Task:', response);

              // If successful then delete the temp entry from the `sync-posts` table
              deleteSingleItemData('sync-posts', response.id);

              console.log(`[SW] Entry ID: ${response.id} Deleted From Queue!`);
            })
            .catch(err => console.log(err));
        }
      })
    );
  }
});

//* PUSH NOTIFICATIONS ------------------------------------------------------------------------------------------------------------------

self.addEventListener('notificationclick', event => {
  const notification = event.notification;
  const action = event.action;

  // `confirm` here isn't a keyword, it's just the ID we gave to one of the notification buttons inside the `displayConfirmNotification()` function
  if (action === 'confirm') {
    console.log('confirm was chosen');
    notification.close(); // Some devices do this automatically but others like android doesn't so calling it explicitly here
  } else {
    console.log(action);
    // If user clicks on the notification and user had a tab open to the site open the link there, otherwise open it in a new tab
    event.waitUntil(
      clients.matchAll().then(clients => {
        const client = clients.find(c => c.visibilityState === 'visible');

        if (client !== undefined) {
          client.navigate(notification.data.openUrl);
          client.focus();
        } else {
          clients.openWindow(notification.data.openUrl);
        }

        notification.close();
      })
    );
  }
});

self.addEventListener('notificationclose', event => {
  // Can send analytics data here since user didn't interact with notification
  console.log('Notification was closed', event);
});

// Will fire whenever a new push message is sent
self.addEventListener('push', event => {
  console.log('[SW] Push Notification Recieved!');
  alert('[SW] Push Notification Recieved!');

  let data = {};
  if (event.data) {
    data = JSON.parse(event.data.text()); // The notification is sent from the server, see "./functions/index.js"
  }

  const options = {
    body: 'You successfully subscribed to our notification service!',
    icon: '/src/images/icons/app-icon-96x96.png',
    badge: '/src/images/icons/app-icon-96x96.png',
    data: {
      openUrl: data.openUrl
    }
  };

  event.waitUntil(self.registration.showNotification(data.title, options));
});
